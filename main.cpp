/*
 *  main.cpp
 *  GenSGFProperties
 *
 *  Created by Ken Friedenbach on 2/25/07.
 *  Copyright 2007-2014 Ken Friedenbach. All rights reserved.
 *
 *	This program reads the property list data from:
 *		http://www.red-bean.com/sgf/proplist.html
 *	which was cut and paste into the input file:
 *		SGF_Properties_Spec.txt
 *	with the change of "-" into "--" in the property type column,
 *	to remove ambiguities with other uses of "-".
 *
 */

#include <cstddef>
#include <string.h>

#include <iostream>
#include <fstream>
using namespace std;

#define GENERATING_SGF_HEADER 1

#include "SGF_File.h"

// This was first use: print the characters, in form suitable for GO_LISP
// extern void character_output(void);
// #include "character_output.h"


const char * Version	= "Version FF[4] 1.0";
const char *  Date		= __DATE__;
const char *  Time		= __TIME__;

// executable is placed in XCODE temporary space so 
// so the data file should be found by full path name:
const char * dataname	= "/Users/ken/Projects/abst-hier/src/gitHub.com/Ken1JF/GenSGFProperties/SGF_Properties_Spec.txt";

// and place the output file in the project directory:
const char * filename	= "/Users/ken/Projects/abst-hier/src/gitHub.com/Ken1JF/GenSGFProperties/SGF_Property_gen.h";

int numProperties = 0;

#define MAX_PROPERTIES 200
char Property_IDs[MAX_PROPERTIES][2];

static size_t max_Description_length				= 1;
static size_t max_Property_type_length				= 1;
static size_t max_Property_type_qualifier_length	= 1;
static size_t max_Property_value_length             = 1;
static size_t max_Property_note_length              = 1;

// These strings are found in the "source" document: SGF_Properties_Spec.txt
// The order of the strings, corresponds to the enum definitions, and the _names[] arrays,
// which are found in include file "SGF_File.h"
const char * SGF_qualifier_strings[] =
{
	"(no-property-qualifier)", // - => blank, no match
	"(inherit)",
	"(LOA)",
	"(Go)",
	"(SGC)",
	NULL
};

const char * SGF_property_strings[] =
{
	"--",
	"root",
	"setup",
	"game-info",
	"move",
	NULL
};

// an array of the value strings found in the SGF_Properties_Spec.txt file
const char * SGF_value_strings[] =
{
	"none | composed number \":\" simpletext",
	"none",
	"compressed list of point",
	"list of composed point ':' simpletext",
	"list of composed point ':' point",
	"elist of point",
	"list of point",
	"point",
	"composed simpletext ':' simpletext",
	"simpletext",
	"text",
	"(number | composed number ':' number)",
	"number (range: 0-3)",
	"number (range: 1-4)",
	"number (range: 1-5,7-16)",
	"number",
	"move",
	"list of stone",
	"stone",
	"real",
	"double",
	"color",
	NULL
};

// an array containing the corresponding enumerated type for each value string
t_SGF_value SGF_value_types [] =
{
	SGF_none_or_comp_num_simtxt,
	SGF_no_value,
	SGC_compressed_list_point,
	SGF_list_comp_point_simtxt,
	SGF_list_comp_point,
	SGF_point_elist,
	SGF_point_list,
	SGF_point,
	SGF_comp_simtxt,
	SGF_simpletext,
	SGF_text,
	SGF_num_or_comp_num,
	SGF_ST_number,
	SGF_FF_number,
	SGF_game_number,
	SGF_number,
	SGF_move,
	SGF_stone_list,
	SGF_stone,
	SGF_real,
	SGF_double,
	SGF_color,
	SGF_no_value // NULL terminates the array of strings, won't be found...
};

static void Gen_File_Header(ostream& os, const char * file_name, const char * version, const char * date, const char * time)
{
	os	<< "/*\n *  "
		<< file_name 
		<< "\n *  GenSGFProperties\n *\n *  Generated by GenSGFProperties "
		<< version 
		<< " on "
		<< date << " at " << time
		<< "\n *  Copyright 2007- 2014 Ken Friedenbach. All rights reserved.\n *\n */\n\n";
}

static void Gen_Property_note(ostream& os, char ch)
{
	size_t len;
	t_SGF_note theNote=SGF_std;
	if (ch == ' ')
		os << SGF_note_type_names[theNote=SGF_std] << ", ";
	else
	if (ch == '*')
		os << SGF_note_type_names[theNote=SGFF4_new] << ", ";
	else
	if (ch == '!')
		os << SGF_note_type_names[theNote=SGFF4_changed] << ", ";
	else
	if (ch == '#')
		os << SGF_note_type_names[theNote=SGF_non_std] << ", ";
	else
	{
		std::cout << "***ERROR*** unknown property flag: " << ch << "\n";
		exit(1);
	}
	os.width(max_Property_note_length+1-(len=strlen(SGF_note_type_names[theNote])));
	os << ' ';
	if (len > max_Property_note_length)
		max_Property_note_length = len;
}

static void Gen_Property_ID(ostream& os, char ID1, char ID2)
{
	if (numProperties < MAX_PROPERTIES)
	{
		Property_IDs[numProperties][0] = ID1;
		Property_IDs[numProperties][1] = ID2;
		numProperties++;
	}
	else
	{
		std::cout << "***ERROR*** too many properties: " << MAX_PROPERTIES << "\n";
		exit(2);
	}	
	
	os << "sgfPropDef SGF_prop_" << ID1 << ID2 << "("
	   << "\"" << ID1;
		if (ID2 != ' ')
			os << ID2 << "\", ";
		else
			os << "\",  ";
}

static char * skip_white_space(char * start)
{
	char * ret = start;
	char ch = *ret;
	while ((ch == ' ') || (ch == '\t'))
	{ 
		ret++;
		ch = *ret;
	}
	return ret;
}


static char * lookUp(char * start, const char * words[], int * The_Index_Found)
{
	int w = 0;
	const char * word = words[w];
	char * search;
	size_t len;
	*The_Index_Found = 0;
	while (word != NULL)
	{
		len = strlen(word);
		search = start;
		while (1)
		{
			if (strncmp(word, search, len) == 0)
			{
				*The_Index_Found = w;
				return search;
			}
			else
			{
				search++;
				if (*search == '\0')
					break;
			}
		}
		w++;
		word = words[w];
	}
	return NULL;
}

// find the property type name, calling lookUp:
//		lookUp returns the location a name is found
//		and sets the index in theOneFound
// find_property_type side effects:
//		marks the end of the Descriptor
//		returns the first character after the property type name
static char * find_property_type(char * Desc_Start, int * theOneFound)
{
	char * prop_type_name;
	char * ret = NULL;
// find the property type name.
	prop_type_name = lookUp(Desc_Start, SGF_property_strings, theOneFound);
	if (prop_type_name == 0)
	{
		std::cout << "***ERROR*** no property type: " << Desc_Start << "\n";
		exit(1);
	}
	else
	{
//		marks the end of the Descriptor
		char * Str_End = prop_type_name-1;
		char ch;
		while (((ch = *Str_End) == ' ') || (ch == '\t')) Str_End--;
		Str_End++;
		*Str_End = '\0';
	}
//		returns the first non-blank after the property type name
	ret = prop_type_name + strlen(SGF_property_strings[*theOneFound]);
	return ret;
}

// find the (optional) property type qualifier, calling lookUp:
//		lookUp returns the location a name is found
//		and sets the index in theOneFound
// find_prop_type_qualifier returns the first char after the qualifier
static char * find_prop_type_qualifier(char * start, int * theOneFound)
{
	char * ret = lookUp(start, SGF_qualifier_strings, theOneFound);
	if (ret == NULL)
	{ 
		*theOneFound = 0;
		ret = start;
	}
	else
	{
		ret = ret + strlen(SGF_qualifier_strings[*theOneFound]) + 1;
	}
	return ret;
}


// find the property value type, calling lookUp:
//		lookUp returns the location a name is found
//		and sets the index in theOneFound
// find_prop_type_qualifier returns the first char after the qualifier
static char * find_prop_value_type(char * start, int * theOneFound)
{
	char * ret = lookUp(start, SGF_value_strings, theOneFound);
	if (ret == NULL)
	{ 
		*theOneFound = 0;
		ret = start;
	}
	else
	{
	// lookUp returns the string index, convert to real index
		*theOneFound = SGF_value_types[*theOneFound];
		ret = ret + strlen(SGF_value_strings[*theOneFound]) + 1;
	}
	return ret;
}

static void Gen_Description_and_Type(ostream& os, char * Desc_Start, int Prop_type_Index)
{
	size_t n = 0;
	os << '"' << Desc_Start << "\", ";
	os.width(max_Description_length-strlen(Desc_Start)+1);
	os << ' ';
	os << SGF_property_type_names[Prop_type_Index] << ", ";
	os.width(max_Property_type_length+3-strlen(SGF_property_type_names[Prop_type_Index]));
	os << ' ';	
// Calculate, for next build:
	if ((n = strlen(Desc_Start)) > max_Description_length)
		max_Description_length = n;
	if ((n = strlen(SGF_property_type_names[Prop_type_Index])) > max_Property_type_length)
		max_Property_type_length = n;
	
}

static void Gen_Qualifier(ostream& os, int Prop_qual_Index)
{
	size_t n = 0;
	
	os << SGF_qualifier_type_names[Prop_qual_Index] << ", ";
	os.width(max_Property_type_qualifier_length+3-(n=strlen(SGF_qualifier_type_names[Prop_qual_Index])));
	os << ' ';

	if (max_Property_type_qualifier_length < n)
		max_Property_type_qualifier_length = n;
}

static void Gen_Value(ostream& os, int Prop_value_Index)
{
	size_t n = 0;
	
	os <<  SGF_value_type_names[Prop_value_Index];
	os.width(max_Property_value_length+3
			-( n=strlen( SGF_value_type_names[Prop_value_Index] ) ) );
	os << ' ';
	if (max_Property_value_length < n)
		max_Property_value_length = n;
}

static void gen_length(ostream& os, size_t len, const char * name)
{
	os << "// const int " << name << " = " << len << ";\n";
}

static void gen_the_Properties(ostream& os)
{
	cout << "Generating " << numProperties << " SGF properties.\n";
	os << "sgfPropDef * the_SGF_Properties[] = \n{\n";
	for (int n = 0; n < numProperties-1; n++)
	{
		os <<	"    &SGF_prop_" << Property_IDs[n][0] << Property_IDs[n][1] << ",\n";
		
	}
		os <<	"    &SGF_prop_" << Property_IDs[numProperties-1][0] << Property_IDs[numProperties-1][1] << "\n";
	os <<		"};\n";
}

static void gen_SGF_properties(void)
{
	filebuf fb;
	ifstream is;

	char buf[256];

	char ch;
	
	char spec;		// ' ' or '!' or '*' or '#'
	char ID1, ID2;	// 1 or 2 char ID (ID2 = ' ' for 1 char ID)
	
	char * Desc_Start;
	char * Prop_value_Start;

	numProperties = 0;
	
	ostream os(&fb);
	fb.open(filename, ios::out);
	
	if (not fb.is_open())
	{
		std::cout << "***ERROR*** can't open: \"" << filename << "\" for output\n";
		exit(2);
	}
	
	Gen_File_Header(os, filename, Version, Date, Time);
	
	is.open(dataname);
	
	if (not is.is_open())
	{
		std::cout << "***ERROR*** can't open: \"" << dataname << "\" for input\n";
		exit(1);
	}
	
	while (is.good())
	{
		int Prop_type_Index;
		int Prop_qual_Index;
		int Prop_value_Index;
		// pick up and process the optional special flag:
		spec = ' ';
		ch = is.get();
		if ((ch == '!') || (ch == '*') || (ch == '#'))
			{ spec = ch; ch = is.get(); }
		

		// pick up the rest of ID, and process it:
		ID1 = ch;  ch = is.get();
		ID2 = ' ';
		if ((ch != ' ') || (ch != '\t'))
			{ ID2 = ch; ch = is.get(); }
		Gen_Property_ID(os, ID1, ID2);
		Gen_Property_note(os, spec);

//		os << ch; // discard the first white-space char... verify?

		// pick up the reast of the line
		is.getline(buf, 256);

		// find the Description and property type
		Desc_Start = skip_white_space(&buf[0]);
		Prop_value_Start = find_property_type(Desc_Start+max_Description_length, &Prop_type_Index );
		Prop_value_Start = skip_white_space(Prop_value_Start);

		Gen_Description_and_Type(os, Desc_Start, Prop_type_Index);
		
		// find the (optional) qualifier and property value string
		Prop_value_Start = find_prop_type_qualifier(Prop_value_Start, &Prop_qual_Index);
		Prop_value_Start = skip_white_space(Prop_value_Start);
		Gen_Qualifier(os, Prop_qual_Index);


		find_prop_value_type(Prop_value_Start, &Prop_value_Index);
		Gen_Value(os, Prop_value_Index);

		os << ");\n";
	}

	gen_length(cout, max_Property_note_length,				"max_Property_note_length" );
	gen_length(cout, max_Description_length,				"max_Description_length" );
	gen_length(cout, max_Property_type_length,				"max_Property_type_length" );
	gen_length(cout, max_Property_type_qualifier_length,	"max_Property_type_qualifier_length" );
	gen_length(cout, max_Property_value_length,				"max_Property_value_length" );

	gen_the_Properties(os);
	
	is.close();

	fb.close();
}

static void EchoArgs (int argc, char * const argv[]) {
	int i;
	cout << argv[0] << " called with " << argc << " arguments.\n";
	for (i=0; i<argc; i++)
		std::cout << "   argv[" << i << "] = \"" << argv[i] << "\"\n";
}

int main (int argc, char * const argv[]) {
//	character_output();
	EchoArgs(argc, argv);
	gen_SGF_properties();
	gen_SGF_properties(); // do it again, with accumulated sizes. 
// (need to do it twice, as part of "bootstrap")
    return 0;
}
